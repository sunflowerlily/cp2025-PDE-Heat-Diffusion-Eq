# 项目4：有限长细杆热传导方程多种数值方法比较

## 项目背景

本项目旨在通过实现和比较四种不同的数值方法来求解一维热传导方程，深入理解偏微分方程数值解法的特点、稳定性和精度。这是计算物理中的核心内容，对理解数值方法的本质具有重要意义。

### 物理问题描述

考虑长度为 $l = 20$ 的有限长细杆，其热传导过程由以下偏微分方程描述：

$$
\frac{\partial u}{\partial t} = a^2 \frac{\partial^2 u}{\partial x^2}
$$

**边界条件：** $u(0, t) = 0, \quad u(l, t) = 0$

**初始条件：** $u(x, 0) = \varphi(x) = \begin{cases} 1 & (10 \leq x \leq 11) \\ 0 & (x < 10, x > 11) \end{cases}$

**物理参数：**
- 热扩散系数：$a^2 = 10$
- 杆长：$l = 20$
- 时间范围：$t \in [0, 25]$

这个问题描述了一个初始时刻在 $x \in [10, 11]$ 区间内温度为1，其他位置温度为0的细杆，在两端保持零温度的边界条件下，温度随时间的扩散过程。

## 学习目标

1. **理解数值方法原理**：掌握显式、隐式和半隐式差分格式的构造原理
2. **分析稳定性条件**：理解CFL条件对显式方法的限制，以及隐式方法的无条件稳定性
3. **比较精度特性**：分析不同方法的时间和空间精度阶数
4. **评估计算效率**：比较各方法的计算复杂度和实际运行时间
5. **掌握现代求解器**：学会使用scipy.solve_ivp处理PDE问题

## 项目任务详述

### 任务1：显式差分法(FTCS)实现

**方法原理：**
前向时间中心空间(Forward Time Central Space)格式使用前向差分近似时间导数，中心差分近似空间导数：

$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = a^2 \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\Delta x)^2}
$$

**离散格式：**
$$
u_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n)
$$

其中稳定性参数 $r = \frac{a^2 \Delta t}{(\Delta x)^2}$

**稳定性条件：**
为保证数值稳定性，必须满足：$r \leq \frac{1}{2}$

**实现要点：**
1. 根据稳定性条件自动选择合适的时间步长
2. 使用NumPy向量化操作提高计算效率
3. 正确处理边界条件：$u_0^n = u_{N_x-1}^n = 0$
4. 实现初始条件的精确离散化

**关键函数：**
- `solve_ftcs(nx, nt, total_time, alpha, initial_condition)`
- `check_stability(r)` - 检查稳定性条件
- `apply_boundary_conditions(u)` - 应用边界条件

### 任务2：隐式差分法(BE)实现

**方法原理：**
后向欧拉(Backward Euler)格式使用后向差分近似时间导数：

$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = a^2 \frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\Delta x)^2}
$$

**矩阵形式：**
$$(I - r A) u^{n+1} = u^n$$

其中 $A$ 是二阶差分算子矩阵：
$$
A = \frac{1}{(\Delta x)^2} \begin{pmatrix}
-2 & 1 & 0 & \cdots & 0 \\
1 & -2 & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \ddots & \vdots \\
0 & \cdots & 1 & -2 & 1 \\
0 & \cdots & 0 & 1 & -2
\end{pmatrix}
$$

**稳定性特点：**
隐式方法无条件稳定，可以使用较大的时间步长。

**实现要点：**
1. 构建三对角稀疏矩阵系统
2. 使用高效的线性方程组求解器
3. 处理边界条件的矩阵修正
4. 优化矩阵存储和计算

**关键函数：**
- `solve_backward_euler(nx, nt, total_time, alpha, initial_condition)`
- `build_tridiagonal_matrix(nx, r)` - 构建系数矩阵
- `solve_linear_system(A, b)` - 求解线性方程组

### 任务3：Crank-Nicolson方法实现

**方法原理：**
Crank-Nicolson方法是隐式和显式方法的平均，具有二阶时间精度：

$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = \frac{a^2}{2} \left[ \frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\Delta x)^2} + \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\Delta x)^2} \right]
$$

**矩阵形式：**
$$
\left(I - \frac{r}{2} A\right) u^{n+1} = \left(I + \frac{r}{2} A\right) u^n
$$

**精度特点：**
- 时间精度：$O(\Delta t^2)$
- 空间精度：$O(\Delta x^2)$
- 无条件稳定

**实现要点：**
1. 构建左端和右端系数矩阵
2. 每个时间步求解线性方程组
3. 利用矩阵的对称性优化计算
4. 验证二阶时间精度

**关键函数：**
- `solve_crank_nicolson(nx, nt, total_time, alpha, initial_condition)`
- `build_cn_matrices(nx, r)` - 构建CN格式矩阵
- `advance_cn_step(u_old, A_left, A_right)` - 单步时间推进

### 任务4：scipy.solve_ivp方法实现

**方法原理：**
将偏微分方程转换为常微分方程组，利用scipy的高级积分器求解：

$$
\frac{du}{dt} = a^2 A u
$$

其中 $u$ 是空间离散后的向量，$A$ 是空间差分算子矩阵。

**ODE系统构建：**
1. 空间离散化：将连续的 $u(x,t)$ 离散为 $u_i(t)$
2. 构建右端函数：`dudt = alpha * A @ u`
3. 设置边界条件：$u_0(t) = u_{N_x-1}(t) = 0$

**积分器选择：**
- `RK45`：自适应Runge-Kutta方法（默认）
- `DOP853`：高精度Dormand-Prince方法
- `Radau`：隐式Runge-Kutta方法（适合刚性问题）
- `BDF`：后向差分公式（适合刚性问题）

**实现要点：**
1. 正确构建ODE系统的右端函数
2. 设置合适的积分器参数
3. 处理边界条件的约束
4. 比较不同积分器的性能

**关键函数：**
- `solve_with_scipy(nx, total_time, alpha, initial_condition, method='RK45')`
- `ode_system(t, u, alpha, A)` - ODE右端函数
- `compare_integrators()` - 比较不同积分器

### 任务5：精度和效率比较分析

**误差计算：**

1. **参考解选择：**
   - 使用高精度数值解作为参考（如高分辨率Crank-Nicolson解）
   - 或使用解析解（如果可获得）

2. **误差范数：**
   - L2误差：$E_{L2} = \sqrt{\sum_{i=1}^{N_x} (u_i^{num} - u_i^{ref})^2 \Delta x}$
   - 最大误差：$E_{\infty} = \max_i |u_i^{num} - u_i^{ref}|$
   - 相对误差：$E_{rel} = \frac{E_{L2}}{\|u^{ref}\|_{L2}}$

3. **收敛性分析：**
   - 网格细化研究：固定 $r$，减小 $\Delta x$ 和 $\Delta t$
   - 收敛阶数计算：$p = \log_2(E_1/E_2)$

**效率评估：**

1. **计算时间测量：**
   ```python
   import time
   start = time.time()
   # 数值计算
   compute_time = time.time() - start
   ```

2. **内存使用分析：**
   - 矩阵存储需求
   - 临时数组大小
   - 内存访问模式

3. **算法复杂度：**
   - 显式方法：$O(N_x N_t)$
   - 隐式方法：$O(N_x N_t)$（利用三对角求解器）
   - solve_ivp：取决于积分器和自适应步长

**比较维度：**
- 精度 vs 计算时间
- 稳定性限制
- 内存需求
- 实现复杂度
- 参数敏感性

## 技术要求

### 编程规范
1. **函数设计：**
   - 清晰的函数签名和文档字符串
   - 合理的参数验证和错误处理
   - 模块化设计，便于测试和重用

2. **代码风格：**
   - 遵循PEP 8规范
   - 有意义的变量名和注释
   - 适当的代码组织和结构

3. **性能优化：**
   - 使用NumPy向量化操作
   - 避免不必要的数组复制
   - 合理使用稀疏矩阵

### 可视化要求
1. **静态图表：**
   - 不同时刻的温度分布
   - 误差随时间的变化
   - 收敛性分析图
   - 计算时间比较

2. **动画制作：**
   - 温度扩散过程动画
   - 多方法结果对比动画

3. **综合分析图：**
   - 精度-效率散点图
   - 误差收敛曲线
   - 稳定性区域图

## 评分细则

### 代码实现 (70分)
- **显式差分法 (18分)：**
  - 正确实现 (10分)
  - 稳定性处理 (4分)
  - 代码质量 (4分)

- **隐式差分法 (18分)：**
  - 矩阵构建 (8分)
  - 线性求解器 (6分)
  - 边界条件处理 (4分)

- **Crank-Nicolson方法 (18分)：**
  - 格式实现 (10分)
  - 精度验证 (4分)
  - 优化技巧 (4分)

- **solve_ivp方法 (11分)：**
  - ODE转换 (6分)
  - 积分器使用 (3分)
  - 参数调优 (2分)

- **比较分析 (5分)：**
  - 误差计算 (2分)
  - 效率测试 (2分)
  - 结果可视化 (1分)

### 实验报告 (30分)
- **方法原理 (8分)：**
  - 理论基础阐述
  - 数值格式推导
  - 稳定性分析

- **结果分析 (12分)：**
  - 数值结果展示
  - 精度比较分析
  - 效率评估

- **讨论总结 (10分)：**
  - 方法优缺点
  - 适用场景分析
  - 改进建议

## 提示与建议

### 调试技巧
1. **从简单情况开始：**
   - 先实现粗网格低精度版本
   - 逐步增加复杂度
   - 使用已知解析解验证

2. **分步验证：**
   - 单独测试每个函数
   - 检查边界条件处理
   - 验证矩阵构建正确性

3. **可视化调试：**
   - 绘制中间结果
   - 检查数值解的物理合理性
   - 观察误差的空间分布

### 常见问题
1. **稳定性问题：**
   - 显式方法出现振荡：检查CFL条件
   - 解发散：检查边界条件实现

2. **精度问题：**
   - 初始条件离散化误差
   - 边界条件处理不当
   - 时间步长选择不合理

3. **效率问题：**
   - 避免循环，使用向量化
   - 合理选择稀疏矩阵格式
   - 预分配数组空间

### 扩展思考
1. **理论深入：**
   - von Neumann稳定性分析
   - 数值色散和耗散
   - 边界条件对稳定性的影响

2. **实际应用：**
   - 非均匀网格处理
   - 变系数问题
   - 多维扩展

3. **高级技术：**
   - 自适应网格细化
   - 并行计算实现
   - GPU加速

---

**重要提醒：**
- 确保所有函数名称与测试文件一致
- 注意数组索引和边界处理
- 保存中间结果便于调试
- 及时备份代码和数据