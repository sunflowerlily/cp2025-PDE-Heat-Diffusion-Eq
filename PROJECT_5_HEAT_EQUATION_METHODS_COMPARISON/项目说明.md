# 项目说明：热传导方程多种数值方法比较

## 项目背景

热传导方程是描述热量在物体中传播的基本偏微分方程，在工程和物理学中有广泛应用。本项目通过实现6种不同的数值方法来求解一维热传导方程，比较它们的精度、稳定性和计算效率。

## 物理问题描述

考虑一根有限长细杆的热传导问题：

$$
\frac{\partial u}{\partial t} = a^2 \frac{\partial^2 u}{\partial x^2}
$$

**边界条件：** $u(0, t) = 0$, $u(l, t) = 0$ （两端温度固定为0）

**初始条件：** 
$$
u(x, 0) = \varphi(x) = \begin{cases} 
1 & \text{if } 10 \leq x \leq 11 \\
0 & \text{otherwise}
\end{cases}
$$

**参数设置：**
- 杆长：$l = 20$
- 总时间：$t = 25$
- 热扩散系数：$a^2 = 10$

## 学习目标

1. **理解不同数值格式的特点**
   - 显式格式：简单但有稳定性限制
   - 隐式格式：稳定但需要求解线性方程组
   - 半隐式格式：平衡精度和稳定性

2. **掌握数值方法的实现**
   - 有限差分离散化
   - 矩阵运算和线性方程组求解
   - ODE求解器的使用

3. **学会精度分析**
   - 数值解与解析解的比较
   - 误差分析和收敛性研究

## 项目任务

### 任务1：实现heat_equation_solver类

创建一个包含以下方法的类：

```python
class heat_equation_solver:
    def __init__(self, L, T, a_squared, nx, nt):
        """初始化求解器参数"""
        pass
    
    def set_initial_condition(self, phi_func):
        """设置初始条件"""
        pass
    
    def ftcs_method(self):
        """显式格式差分法 (Forward Time Central Space)"""
        pass
    
    def laplace_explicit_method(self):
        """使用Laplace算符的显式格式"""
        pass
    
    def btcs_method(self):
        """隐式格式差分法 (Backward Time Central Space)"""
        pass
    
    def crank_nicolson_method(self):
        """Crank-Nicolson方法"""
        pass
    
    def modified_crank_nicolson_method(self):
        """变形Crank-Nicolson方法"""
        pass
    
    def solve_ivp_method(self):
        """使用scipy.integrate.solve_ivp求解"""
        pass
    
    def compare_methods(self):
        """比较所有方法的精度"""
        pass
```

### 任务2：数值方法详解

#### 2.1 显式格式 (FTCS)
离散化方程：
$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = a^2 \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\Delta x)^2}
$$

稳定性条件：$r = \frac{a^2 \Delta t}{(\Delta x)^2} \leq 0.5$

#### 2.2 隐式格式 (BTCS)
离散化方程：
$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = a^2 \frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\Delta x)^2}
$$

无条件稳定，需要求解三对角线性方程组。

#### 2.3 Crank-Nicolson方法
时间方向使用中心差分：
$$
\frac{u_i^{n+1} - u_i^n}{\Delta t} = \frac{a^2}{2}\left[\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\Delta x)^2} + \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\Delta x)^2}\right]
$$

二阶精度，无条件稳定。

### 任务3：精度比较分析

1. **实现解析解**（如果存在）或高精度参考解
2. **计算各方法的误差**：L2范数、最大误差
3. **分析收敛性**：不同网格下的误差变化
4. **比较计算效率**：运行时间对比

## 技术要求

### 编程规范
- 使用numpy进行数组操作
- 使用scipy.sparse处理稀疏矩阵
- 使用matplotlib进行可视化
- 代码模块化，函数功能单一
- 添加详细注释和文档字符串

### 数值技巧
- 合理选择时间步长和空间步长
- 使用稀疏矩阵提高计算效率
- 实现边界条件的正确处理
- 注意数值稳定性问题

## 提示与资源

### 关键算法提示
1. **三对角矩阵求解**：使用`scipy.linalg.solve_banded`
2. **稀疏矩阵操作**：使用`scipy.sparse`模块
3. **ODE求解**：将PDE转换为ODE系统使用`solve_ivp`

### 参考资料
- 数值分析教材中的偏微分方程章节
- SciPy官方文档
- 有限差分方法相关论文

## 评分标准

### 代码实现 (60分)
- 6种方法正确实现：每种方法8分
- 边界条件处理：6分
- 初始条件设置：6分

### 精度分析 (25分)
- 误差计算：10分
- 方法比较：10分
- 结果可视化：5分

### 代码质量 (15分)
- 代码结构和注释：8分
- 运行效率：4分
- 文档完整性：3分

## 扩展思考

1. **稳定性分析**：为什么显式方法有稳定性限制？
2. **精度比较**：哪种方法在相同计算成本下精度最高？
3. **实际应用**：不同方法适用于什么样的实际问题？
4. **算法优化**：如何进一步提高计算效率？

## 提交要求

1. 完成`heat_equation_methods_student.py`中的所有函数实现
2. 提交实验报告，包含：
   - 方法实现说明
   - 精度比较结果
   - 算法分析和总结
3. 确保代码能够正确运行并通过测试